1.为什么需要继承？
    1）任务类型不同，管理方式相同
    2）无需知道任务类型，只需要TaskBase*指针
    3）用统一接口管理不同对象
2.为什么不能用std::vector<int>存储？
    vector扩容会移动位置，指针指向的地址会变成无效地址，
    所以要用原子变量，原子指针，保证元素地址稳定
3.为什么需要stop(),而不能直接析构？
    1）未join()就析构，程序会奔溃
    2）线程不能自动停止

分析：（有些表达可能有误，只是自己的理解）
「处理模块管理类」：实现每一个任务的具体功能，依据task.md需要一个基类（三个任务类抽象属性相似）
「任务管理类」：管理每个任务，实现类似流水线的效果
所以需要三个源文件，一个主程序(main.cpp)，一个源文件定义「处理模块管理类」(TaskBase.cpp)，一个源文件「任务管理类」(TaskManager.cpp)
为了让程序更清晰，除主程序的源文件可以分为一个头文件(Taskxx.h)（定义类，声明函数）一个源文件(Taskxx.cpp)（定义函数），
其实如果主函数比较复杂，也可以将主函数也分开，不过这里没有必要

//////////「处理模块管理类」//////////
TaskBase.h/TaskBase.cpp
被管理的「任务」（数据处理模块）具有以下抽象属性：

- 具有一个`int`类型的标识符`key`（例如传感器通道号或模块编号）
- 具有一个回调函数`void callback(int msg)`
- 具有一个运行函数`void run()`  
- 具有一个停止函数`void stop()`
- 内部持有两个`int`类型指针`int *p_in, *p_out`
  - 持续监视`p_in`指向的变量，当`*p_in`不为`0`时，表示有新的「待处理采样值」
  - 对`*p_in`做相应的**运算**，并将其置零
  - 将运算结果写入`*p_out`（表示传给下游模块或最终输出）
  - 你不一定真的要存储`int *`，这里只是表示你需要操作两个指定地址的变量
初始化：TaskBase(int k,atomic<int>* pin,atomic<int>* pout);
析构函数（销毁时自动调用）：virtual ~TaskBase();
一般函数（每个继承此基类的都有，且内容相同，所以用一般的函数）：
void start();
void stop();
虚函数（继承类中可以通过override改成不同的功能（函数定义））：
virtual void run()=0;
virtual void callback(int msg)=0;
int getKey() const{return key;}
让TaskManager能通过key查找某个任务

1. TaskFilter（简单滤波任务）

   - 用于对传感器输入做基础滤波或偏移校正
   - 运算：将`(*p_in) + 1`的值写入`*p_out`，然后将`*p_in`置零
     - 可以理解为给采样值做一个简单的偏移校正
   - `callback(int msg)`：将`*p_in`的值修改为`msg`
     - 相当于通过外部控制直接注入一条新的原始采样值
   - 每次写入`*p_out`时，需要输出一行日志：  
     `write Filter-{key}: {val}`  
     其中`val`为写入的值

2. TaskGain（带放大系数的增益任务）

   - 内部含有一个比例系数`k`，初始为`1`
   - 运算：将`(*p_in) * k`的值写入`*p_out`，然后将`*p_in`置零
     - 可理解为对传感器信号做放大或缩小
   - `callback(int msg)`：
     - 将内部系数`k`修改为`msg`
     - 将`*p_in`修改为`1`（表示外部希望立即触发一次以新系数`k`为参数的测试或标定）
   - 每次写入`*p_out`时，需要输出：  
     `write Gain-{key}: {val}`

3. TaskDelayBuffer（带短延迟的缓冲任务）

   - 模拟处理链中的短暂缓冲或双阶段写入逻辑
   - 运算逻辑：
     1. 将`*p_in`的值暂存为`t`
     2. 将`*p_in`置零
     3. 将`t`写入`*p_out`
     4. 延迟`1ms`
     5. 将`t + 1`再次写入`*p_out`
   - `callback(int msg)`：将`*p_in`的值修改为`msg`，表示外部注入一个新的缓冲输入
   - 每次写入`*p_out`时都需要输出：  
     `write Delay-{key}: {val}`

注意：上述三种任务写入`*p_out`时必须遵循统一的输出格式，只是`{kind}`不同（Filter/Gain/Delay），用于方便测试和日志检查。

//////////「任务管理类」//////////
「任务管理类」具有以下属性：
- 存在一个`int`类型的变量`out`，表示最终输出到主控程序的告警或处理结果
- 当任务管理类中有`n`个任务时，也对应存有`n`个`int`类型的变量`b_1, b_2, ..., b_n`，表示模块间的「中间缓冲区」：
  - 对于第`i`个任务来说，它应当监视`b_i`（对应上面的`p_in`），并操作`b_{i-1}`（对应上面的`p_out`）
  - 特别地，第`1`个任务应当监视`b_1`并将结果写入`out`变量（`p_out`指向`out`）
- 因此整个流水线结构类似：
  - 传感器或外部控制 → `b_n` → 第`n`个任务 → `b_{n-1}` → … → 第`1`个任务 → `out` → 主控程序

e.g.假设任务数 = 3
           b3           b2           b1
Sensor → [a[2]] ← Task3 ← [a[1]] ← Task2 ← [a[0]] ← Task1 ← out

任务编号	监视(p_in)	写入(p_out)
Task3(n)   b₃ (a[2])   b₂ (a[1])
Task2	   b₂ (a[1])   b₁ (a[0])
Task1(1)   b₁ (a[0])   out

一个流水线：1.每个任务都是一个功能单元 2.每个任务从后往前处理 3.最终第1个任务写出结果到主控程序
「任务管理类」需要具有以下功能：
- 线程1：监视变量`out`
  - 当`out`不为`0`时，表示有新的处理结果到达
  - 将`out`的值输出到标准输出（例如打印一行日志），然后将`out`置零
- 线程2：从标准输入`cin`接收控制指令，实现对流水线结构的动态管理：
  - 添加一个任务至末尾  
    命令格式：`add {key} {kind}`  
    其中`key`为任务标识符，`kind`为任务类型（见下文三种任务类型）。添加后任务应当自动进入运行状态（例如，你可以为该任务创建并启动一个线程，在线程中执行其`run`函数）。
  - 从末尾删除一个任务  
    命令格式：`pop`  
    删除当前流水线最末尾的任务，应当安全停止其线程、释放资源，并更新管理类中`b_i`的连接关系。
  - 触发一次回调  
    命令格式：`callback {key} {msg}`  
    查找标识符为`key`的任务，调用其`callback(int msg)`函数，传入`msg`作为参数，用于动态调整任务行为或注入新输入。

初始化：TaskManager();
析构函数：~TaskManager();
添加：void addTask(int key,int kind);
删除：void popTask();
回调：void callback(int key,int msg);
启动两个后台线程
线程1-监控out/线程2-接受用户输入：void run();
exit（停止系统）：bool isRunning() const {return running.load();}

//////////[主函数]//////////
1.创建TaskManager
2.调用manager.run()→启动两个后台线程（t1、t2）
3.主线程不断检查running
4.当用户在输入线程输入 exit 时：
    running = false
    main() loop跳出
5.main返回，manager自动析构
6.析构函数安全停止所有任务和线程

